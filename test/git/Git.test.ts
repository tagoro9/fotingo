jest.mock('simple-git/promise');
import 'jest';
import * as simpleGitMock from 'simple-git/promise';
import { Git } from 'src/git/Git';
import { GitErrorType } from 'src/git/GitError';
import data from 'test/lib/data';

const simpleGit = (simpleGitMock as any) as jest.Mock;

let git: Git;
const issue = data.createIssue();
const gitConfig = data.createGitConfig();
const branchName = issue.key;
const latestCommitHash = '547433c';
const remoteBranch = `${gitConfig.remote}/${gitConfig.baseBranch}`;
const remote = 'git@github.com:tagoro9/fotingo-rewrite.git';

const gitMocks = {
  checkoutBranch: jest.fn().mockResolvedValue(undefined),
  fetch: jest.fn().mockResolvedValue(undefined),
  getRemotes: jest.fn().mockResolvedValue([
    {
      name: 'origin',
      refs: {
        fetch: remote,
        push: remote,
      },
    },
  ]),
  log: jest.fn().mockResolvedValue({
    latest: {
      hash: latestCommitHash,
    },
  }),
  push: jest.fn().mockResolvedValue(undefined),
  revparse: jest.fn().mockResolvedValue(branchName),
  stash: jest.fn().mockResolvedValue(undefined),
  status: jest.fn().mockResolvedValue({
    files: [],
  }),
};

describe('Git', () => {
  beforeEach(() => {
    simpleGit.mockReturnValue(gitMocks);
    git = new Git(gitConfig);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('getBranchNameForIssue', () => {
    it('should generate a branch name for an issue', () => {
      expect(git.getBranchNameForIssue(issue)).toMatchSnapshot();
    });
  });

  describe('getIssues', () => {
    it('should get the issue from the branch name', async () => {
      const issueId = await git.getIssues();
      expect(issueId).toBe(issue.key);
      expect(gitMocks.revparse).toBeCalledWith(['--abrev-ref', 'HEAD']);
    });
  });

  describe('push', () => {
    it('should do a git push', async () => {
      await git.push();
      expect(gitMocks.push).toBeCalledTimes(1);
    });

    it('should throw an error if there is no upstream branch', async () => {
      gitMocks.push.mockRejectedValue(new Error('has no upstream branch'));
      try {
        await git.push();
      } catch (e) {
        expect(e.message).toBe('NO_UPSTREAM');
      }
    });
  });

  describe('createBranchAndStashChanges', () => {
    it('should fetch and create a branch from the latest commit', async () => {
      await git.createBranchAndStashChanges(branchName);
      expect(gitMocks.fetch).toHaveBeenCalledTimes(1);
      expect(gitMocks.status).toHaveBeenCalledTimes(1);
      expect(gitMocks.log).toHaveBeenCalledWith(['-n1', remoteBranch]);
      expect(gitMocks.checkoutBranch).toHaveBeenCalledWith(branchName, latestCommitHash);
      expect(gitMocks.stash).not.toHaveBeenCalled();
    });

    it('should stash any existing change before creating the branch', async () => {
      gitMocks.status.mockResolvedValue({ files: ['some file.txt'] });
      await git.createBranchAndStashChanges(branchName);
      expect(gitMocks.fetch).toHaveBeenCalledTimes(1);
      expect(gitMocks.stash).toHaveBeenCalledWith([
        'save',
        '--include-untracked',
        'Auto generated by fotingo',
      ]);
      expect(gitMocks.status).toHaveBeenCalledTimes(1);
      expect(gitMocks.log).toHaveBeenCalledWith(['-n1', remoteBranch]);
      expect(gitMocks.checkoutBranch).toHaveBeenCalledWith(branchName, latestCommitHash);
    });

    it('should throw an error if a branch already exists', async () => {
      gitMocks.checkoutBranch.mockRejectedValue(
        new Error(`A branch named ${branchName} already exists`),
      );
      try {
        await git.createBranchAndStashChanges(branchName);
      } catch (e) {
        expect(e.code).toBe(GitErrorType.BRANCH_ALREADY_EXISTS);
      }
    });
  });

  describe('getRemote', () => {
    it('should return the parsed remote', async () => {
      await expect(git.getRemote('origin')).resolves.toMatchSnapshot();
      expect(gitMocks.getRemotes).toHaveBeenCalledWith(true);
    });

    it('should fall back to the first remote if it cannot find the specified one', async () => {
      await expect(git.getRemote('some_remote')).resolves.toMatchSnapshot();
      expect(gitMocks.getRemotes).toHaveBeenCalledWith(true);
    });

    it('should throw an error if there are no remotes', async () => {
      gitMocks.getRemotes.mockResolvedValue([]);
      await expect(git.getRemote('origin')).rejects.toBeUndefined();
    });
  });
});
