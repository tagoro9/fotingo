jest.mock('simple-git/promise');
import 'jest';

import * as simpleGitMock from 'simple-git/promise';
import { Git } from 'src/git/Git';
import { GitErrorType } from 'src/git/GitError';
import { Messenger } from 'src/io/messenger';
import { data } from 'test/lib/data';

const simpleGit = (simpleGitMock as unknown) as jest.Mock;

let git: Git;
const issue = data.createIssue();
const gitConfig = data.createGitConfig();
const branchName = issue.key;
const latestCommitHash = '547433c';
const remoteBranch = `remotes/${gitConfig.remote}/${gitConfig.baseBranch}`;
const remote = 'git@github.com:tagoro9/fotingo-rewrite.git';

const gitMocks = {
  branch: jest.fn().mockResolvedValue({ all: ['remotes/origin/master'] }),
  branchLocal: jest.fn().mockResolvedValue({ all: [] }),
  checkoutBranch: jest.fn().mockResolvedValue(undefined),
  fetch: jest.fn().mockResolvedValue(undefined),
  getRemotes: jest.fn().mockResolvedValue([
    {
      name: 'origin',
      refs: {
        fetch: remote,
        push: remote,
      },
    },
  ]),
  log: jest.fn().mockResolvedValue({
    latest: {
      hash: latestCommitHash,
    },
  }),
  push: jest.fn().mockResolvedValue(undefined),
  raw: jest.fn().mockResolvedValue(undefined),
  revparse: jest.fn().mockResolvedValue(branchName),
  stash: jest.fn().mockResolvedValue(undefined),
  status: jest.fn().mockResolvedValue({
    files: [],
  }),
};

describe('Git', () => {
  beforeEach(() => {
    simpleGit.mockReturnValue({ silent: () => gitMocks });
    git = new Git(gitConfig, new Messenger());
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('getBranchNameForIssue', () => {
    it('should generate a branch name for an issue', () => {
      expect(git.getBranchNameForIssue(data.createIssue())).toMatchSnapshot();
    });
  });

  describe('push', () => {
    it('should do a git push', async () => {
      await git.push();
      expect(gitMocks.push).toBeCalledTimes(1);
    });
  });

  describe('createBranchAndStashChanges', () => {
    it('should fetch and create a branch from the latest commit', async () => {
      await git.createBranchAndStashChanges(branchName);
      expect(gitMocks.fetch).toHaveBeenCalledTimes(1);
      expect(gitMocks.status).toHaveBeenCalledTimes(1);
      expect(gitMocks.log).toHaveBeenCalledWith(['-n1', remoteBranch]);
      expect(gitMocks.checkoutBranch).toHaveBeenCalledWith(branchName, latestCommitHash);
      expect(gitMocks.stash).not.toHaveBeenCalled();
    });

    it('should stash any existing change before creating the branch', async () => {
      gitMocks.status.mockResolvedValue({ files: ['some file.txt'] });
      await git.createBranchAndStashChanges(branchName);
      expect(gitMocks.fetch).toHaveBeenCalledTimes(1);
      expect(gitMocks.stash).toHaveBeenCalledWith([
        'save',
        '--include-untracked',
        'Auto generated by fotingo',
      ]);
      expect(gitMocks.status).toHaveBeenCalledTimes(1);
      expect(gitMocks.log).toHaveBeenCalledWith(['-n1', remoteBranch]);
      expect(gitMocks.checkoutBranch).toHaveBeenCalledWith(branchName, latestCommitHash);
    });

    it('should throw an error if a branch already exists', async () => {
      gitMocks.checkoutBranch.mockRejectedValue(
        new Error(`A branch named ${branchName} already exists`),
      );
      try {
        await git.createBranchAndStashChanges(branchName);
      } catch (e) {
        // eslint-disable-next-line jest/no-try-expect
        expect(e.code).toBe(GitErrorType.BRANCH_ALREADY_EXISTS);
      }
    });
  });

  describe('getRemote', () => {
    it('should return the parsed remote', async () => {
      await expect(git.getRemote('origin')).resolves.toMatchSnapshot();
      expect(gitMocks.getRemotes).toHaveBeenCalledWith(true);
    });

    it('should fall back to the first remote if it cannot find the specified one', async () => {
      await expect(git.getRemote('some_remote')).resolves.toMatchSnapshot();
      expect(gitMocks.getRemotes).toHaveBeenCalledWith(true);
    });

    it('should throw an error if there are no remotes', async () => {
      gitMocks.getRemotes.mockResolvedValue([]);
      await expect(git.getRemote('origin')).rejects.toBeUndefined();
    });
  });

  describe('getBranchInfo', () => {
    it('should return the parsed commit history', async () => {
      const baseCommit = {
        author_email: 'test@fotingo.com',
        author_name: 'Fotingo',
        date: 'Fri Jun 26 08:09:23 2020 -0700',
      };
      const commits = [
        {
          ...baseCommit,
          hash: '570768fc6dee7d8983d323555146eb9529f0b701',
          message: 'fix(something): fix this\n\nFixes #FOTINGO-123',
        },
        {
          ...baseCommit,
          hash: 'bf4cf25bdfa6f9c9fffd6226a55071620b1e83a2',
          message: 'feat(that): implement that\n\nfixes #FOTINGO-12',
        },
        {
          ...baseCommit,
          hash: '3955a5ec9ed98ae53ebd49a70bed0a0523a08d61',
          message: 'chore: improve this\n\nFixes #FOTINGO-1',
        },
      ];
      gitMocks.raw.mockResolvedValue(commits[0].hash);
      gitMocks.log.mockResolvedValue({ all: commits });
      await expect(git.getBranchInfo()).resolves.toMatchSnapshot();
    });
  });
});
